(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('gojs')) :
    typeof define === 'function' && define.amd ? define('gojs-angular', ['exports', '@angular/core', 'gojs'], factory) :
    (global = global || self, factory(global['gojs-angular'] = {}, global.ng.core, global.gojs));
}(this, (function (exports, core, gojs) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/diagram.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DiagramComponent = /** @class */ (function () {
        function DiagramComponent(_differs, _kvdiffers, zone) {
            this._differs = _differs;
            this._kvdiffers = _kvdiffers;
            this.zone = zone;
            // Link data for diagram
            this.linkDataArray = null; // optional
            // optional
            // Model data for diagram
            this.modelData = null; // optional
            // model changed listener function for diagram
            this.modelChangedListener = null;
            // event emitter -- fires when diagram model changes. Capture this emitted event in parent component
            this.modelChange = new core.EventEmitter();
            this.diagram = null;
            // differs used to check if there have been changed to the array @Inputs
            // without them, changes to the input arrays won't register in ngOnChanges,
            // since the array reference itself may be the same
            this._ndaDiffer = this._differs.find([]).create(null);
            this._ldaDiffer = this._differs.find([]).create(null);
            // also watch if model data changes; this differ must be initialized in ngOnInit
        }
        /**
         * @return {?}
         */
        DiagramComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            // initialize the differ that listens for changes to modelData object
            if (this.modelData) {
                this._mdDiffer = this._kvdiffers.find(this.modelData).create();
            }
        }; // end ngOnInit
        /**
         * Initializes diagram / model after view init
         */
        // end ngOnInit
        /**
         * Initializes diagram / model after view init
         * @return {?}
         */
        DiagramComponent.prototype.ngAfterViewInit = 
        // end ngOnInit
        /**
         * Initializes diagram / model after view init
         * @return {?}
         */
        function () {
            var _this = this;
            this.diagram = this.initDiagram();
            // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
            // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
            // If some state-altering behavior must happen on a mousemove event inside the diagram,
            // you will have to using zone.run() to make sure that event triggers angular change detection
            this.diagram.addEventListener = (/**
             * @param {?} DOMElement
             * @param {?} name
             * @param {?} listener
             * @param {?} capture
             * @return {?}
             */
            function (DOMElement, name, listener, capture) {
                /** @type {?} */
                var superAddEventListener = gojs.Diagram.prototype.addEventListener;
                if (name === 'mousemove') {
                    _this.zone.runOutsideAngular((/**
                     * @return {?}
                     */
                    function () { return superAddEventListener.call(_this, DOMElement, name, listener, capture); }));
                }
                else {
                    _this.zone.run((/**
                     * @return {?}
                     */
                    function () {
                        superAddEventListener.call(_this, DOMElement, name, listener, capture);
                    }));
                }
            });
            // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
            // using the overridden addEventListener function above
            /** @type {?} */
            var divRef = this.diagramDiv.nativeElement;
            if (divRef === null)
                return;
            this.diagram.div = divRef;
            // initialize the Diagram's model
            this.diagram.delayInitialization((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var model = _this.diagram.model;
                model.commit((/**
                 * @param {?} m
                 * @return {?}
                 */
                function (m) {
                    m.mergeNodeDataArray(m.cloneDeep(_this.nodeDataArray));
                    if (_this.linkDataArray && m instanceof gojs.GraphLinksModel) {
                        m.mergeLinkDataArray(m.cloneDeep(_this.linkDataArray));
                    }
                    if (_this.modelData) {
                        m.assignAllDataProperties(m.modelData, _this.modelData);
                    }
                }), null);
            }));
            // initializer listener
            this.modelChangedListener = (/**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                if (e.isTransactionFinished) {
                    // this must be done within a NgZone.run block, so changes are detected in the parent component
                    _this.zone.run((/**
                     * @return {?}
                     */
                    function () {
                        /** @type {?} */
                        var dataChanges = (/** @type {?} */ (e.model)).toIncrementalData(e);
                        _this.modelChange.emit(dataChanges);
                    }));
                }
            });
            this.diagram.addModelChangedListener(this.modelChangedListener);
        }; // end ngAfterViewInit
        /**
         * Always be checking if array Input data has changed (node and link data arrays)
         */
        // end ngAfterViewInit
        /**
         * Always be checking if array Input data has changed (node and link data arrays)
         * @return {?}
         */
        DiagramComponent.prototype.ngDoCheck = 
        // end ngAfterViewInit
        /**
         * Always be checking if array Input data has changed (node and link data arrays)
         * @return {?}
         */
        function () {
            /** @type {?} */
            var nodeDataArrayChanges = this._ndaDiffer.diff(this.nodeDataArray);
            /** @type {?} */
            var linkDataArrayChanges = this._ldaDiffer.diff(this.linkDataArray);
            /** @type {?} */
            var modelDataChanges = null;
            if (this._mdDiffer) {
                modelDataChanges = this._mdDiffer.diff(this.modelData);
            }
            if (nodeDataArrayChanges || linkDataArrayChanges || modelDataChanges) {
                this.updateFromAppData();
            }
        }; // end ngDoCheck
        /**
         * Some input property has changed (or its contents changed) in parent component.
         * Update diagram data accordingly
         */
        // end ngDoCheck
        /**
         * Some input property has changed (or its contents changed) in parent component.
         * Update diagram data accordingly
         * @return {?}
         */
        DiagramComponent.prototype.updateFromAppData = 
        // end ngDoCheck
        /**
         * Some input property has changed (or its contents changed) in parent component.
         * Update diagram data accordingly
         * @return {?}
         */
        function () {
            if (!this.diagram)
                return;
            /** @type {?} */
            var model = this.diagram.model;
            // don't need model change listener while performing known data updates
            if (this.modelChangedListener !== null)
                model.removeChangedListener(this.modelChangedListener);
            model.startTransaction('update data');
            model.mergeNodeDataArray(model.cloneDeep(this.nodeDataArray));
            if (this.linkDataArray && model instanceof gojs.GraphLinksModel) {
                model.mergeLinkDataArray(model.cloneDeep(this.linkDataArray));
            }
            if (this.modelData) {
                model.assignAllDataProperties(model.modelData, this.modelData);
            }
            model.commitTransaction('update data');
            // reset the model change listener
            if (this.modelChangedListener !== null)
                model.addChangedListener(this.modelChangedListener);
        };
        DiagramComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'gojs-diagram',
                        template: '<div #ngDiagram [className]=divClassName></div>'
                    }] }
        ];
        /** @nocollapse */
        DiagramComponent.ctorParameters = function () { return [
            { type: core.IterableDiffers },
            { type: core.KeyValueDiffers },
            { type: core.NgZone }
        ]; };
        DiagramComponent.propDecorators = {
            initDiagram: [{ type: core.Input }],
            nodeDataArray: [{ type: core.Input }],
            linkDataArray: [{ type: core.Input }],
            modelData: [{ type: core.Input }],
            divClassName: [{ type: core.Input }],
            modelChangedListener: [{ type: core.Input }],
            modelChange: [{ type: core.Output }],
            diagramDiv: [{ type: core.ViewChild, args: ['ngDiagram', { static: true },] }]
        };
        return DiagramComponent;
    }());
    if (false) {
        /**
         * Diagram initialization function. Returns a go.Diagram.
         * Do not initialize model data in this function.
         * @type {?}
         */
        DiagramComponent.prototype.initDiagram;
        /** @type {?} */
        DiagramComponent.prototype.nodeDataArray;
        /** @type {?} */
        DiagramComponent.prototype.linkDataArray;
        /** @type {?} */
        DiagramComponent.prototype.modelData;
        /** @type {?} */
        DiagramComponent.prototype.divClassName;
        /** @type {?} */
        DiagramComponent.prototype.modelChangedListener;
        /** @type {?} */
        DiagramComponent.prototype.modelChange;
        /** @type {?} */
        DiagramComponent.prototype.diagramDiv;
        /** @type {?} */
        DiagramComponent.prototype.diagram;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._ndaDiffer;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._ldaDiffer;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._mdDiffer;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._differs;
        /**
         * @type {?}
         * @private
         */
        DiagramComponent.prototype._kvdiffers;
        /** @type {?} */
        DiagramComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/palette.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PaletteComponent = /** @class */ (function () {
        function PaletteComponent(_differs, _kvdiffers, zone) {
            this._differs = _differs;
            this._kvdiffers = _kvdiffers;
            this.zone = zone;
            // Link data for palette. Optional
            this.linkDataArray = null;
            // Model data for palette. Optional
            this.modelData = null;
            // model changed listener function for palette
            this.modelChangedListener = null;
            // event emitter -- fires when palette model changes. Capture this emitted event in parent component
            this.modelChange = new core.EventEmitter();
            // The Palette itself
            this.palette = null;
            // differs used to check if there have been changed to the array @Inputs
            // without them, changes to the input arrays won't register in ngOnChanges,
            // since the array reference itself may be the same
            this._ndaDiffer = this._differs.find([]).create(null);
            this._ldaDiffer = this._differs.find([]).create(null);
            // also watch if model data changes; this differ must be initialized in ngOnInit
        } // end constructor
        // end constructor
        /**
         * @return {?}
         */
        PaletteComponent.prototype.ngOnInit = 
        // end constructor
        /**
         * @return {?}
         */
        function () {
            // initialize the differ that listens for changes to modelData object
            if (this.modelData) {
                this._mdDiffer = this._kvdiffers.find(this.modelData).create();
            }
        }; // end ngOnInit
        /**
         * Initialize Palette after view init
         */
        // end ngOnInit
        /**
         * Initialize Palette after view init
         * @return {?}
         */
        PaletteComponent.prototype.ngAfterViewInit = 
        // end ngOnInit
        /**
         * Initialize Palette after view init
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.paletteDiv)
                return;
            this.palette = this.initPalette();
            // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
            // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
            // If some state-altering behavior must happen on a mousemove event inside the palette,
            // you will have to using zone.run() to make sure that event triggers angular change detection
            this.palette.addEventListener = (/**
             * @param {?} DOMElement
             * @param {?} name
             * @param {?} listener
             * @param {?} capture
             * @return {?}
             */
            function (DOMElement, name, listener, capture) {
                /** @type {?} */
                var superAddEventListener = gojs.Diagram.prototype.addEventListener;
                if (name === 'mousemove') {
                    _this.zone.runOutsideAngular((/**
                     * @return {?}
                     */
                    function () { return superAddEventListener.call(_this, DOMElement, name, listener, capture); }));
                }
                else {
                    _this.zone.run((/**
                     * @return {?}
                     */
                    function () {
                        superAddEventListener.call(_this, DOMElement, name, listener, capture);
                    }));
                }
            });
            // assign the Palette's div, which (among many other things) will attach a bunch of listeners to the canvas,
            // using the overridden addEventListener function above
            /** @type {?} */
            var divRef = this.paletteDiv.nativeElement;
            this.palette.div = divRef;
            // initialize palette model
            this.palette.delayInitialization((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var model = _this.palette.model;
                model.commit((/**
                 * @param {?} m
                 * @return {?}
                 */
                function (m) {
                    m.mergeNodeDataArray(m.cloneDeep(_this.nodeDataArray));
                    if (_this.linkDataArray && m instanceof gojs.GraphLinksModel) {
                        m.mergeLinkDataArray(m.cloneDeep(_this.linkDataArray));
                    }
                    if (_this.modelData) {
                        m.assignAllDataProperties(m.modelData, _this.modelData);
                    }
                }), null);
            }));
            // initializer listener
            this.modelChangedListener = (/**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                if (e.isTransactionFinished) {
                    // this must be done within a NgZone.run block, so changes are detected in the parent component
                    _this.zone.run((/**
                     * @return {?}
                     */
                    function () {
                        /** @type {?} */
                        var dataChanges = (/** @type {?} */ (e.model)).toIncrementalData(e);
                        _this.modelChange.emit(dataChanges);
                    }));
                }
            });
            this.palette.addModelChangedListener(this.modelChangedListener);
        }; // end ngAfterViewInit
        /**
         * Always be checking if array Input data has changed (node and link data arrays)
         */
        // end ngAfterViewInit
        /**
         * Always be checking if array Input data has changed (node and link data arrays)
         * @return {?}
         */
        PaletteComponent.prototype.ngDoCheck = 
        // end ngAfterViewInit
        /**
         * Always be checking if array Input data has changed (node and link data arrays)
         * @return {?}
         */
        function () {
            /** @type {?} */
            var nodeDataArrayChanges = this._ndaDiffer.diff(this.nodeDataArray);
            /** @type {?} */
            var linkDataArrayChanges = this._ldaDiffer.diff(this.linkDataArray);
            /** @type {?} */
            var modelDataChanges = null;
            if (this._mdDiffer) {
                modelDataChanges = this._mdDiffer.diff(this.modelData);
            }
            if (nodeDataArrayChanges || linkDataArrayChanges || modelDataChanges) {
                this.updateFromAppData();
            }
        }; // end ngDoCheck
        /**
         * Some input property has changed (or its contents changed) in parent component.
         * Update palette data accordingly
         */
        // end ngDoCheck
        /**
         * Some input property has changed (or its contents changed) in parent component.
         * Update palette data accordingly
         * @return {?}
         */
        PaletteComponent.prototype.updateFromAppData = 
        // end ngDoCheck
        /**
         * Some input property has changed (or its contents changed) in parent component.
         * Update palette data accordingly
         * @return {?}
         */
        function () {
            if (!this.palette)
                return;
            /** @type {?} */
            var model = this.palette.model;
            model.startTransaction('update data');
            model.mergeNodeDataArray(model.cloneDeep(this.nodeDataArray));
            if (this.linkDataArray && model instanceof gojs.GraphLinksModel) {
                model.mergeLinkDataArray(model.cloneDeep(this.linkDataArray));
            }
            if (this.modelData) {
                model.assignAllDataProperties(model.modelData, this.modelData);
            }
            model.commitTransaction('update data');
        };
        PaletteComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'gojs-palette',
                        template: '<div #ngPalette [className]=divClassName></div>'
                    }] }
        ];
        /** @nocollapse */
        PaletteComponent.ctorParameters = function () { return [
            { type: core.IterableDiffers },
            { type: core.KeyValueDiffers },
            { type: core.NgZone }
        ]; };
        PaletteComponent.propDecorators = {
            initPalette: [{ type: core.Input }],
            nodeDataArray: [{ type: core.Input }],
            linkDataArray: [{ type: core.Input }],
            modelData: [{ type: core.Input }],
            divClassName: [{ type: core.Input }],
            modelChangedListener: [{ type: core.Input }],
            modelChange: [{ type: core.Output }],
            paletteDiv: [{ type: core.ViewChild, args: ['ngPalette', { static: true },] }]
        };
        return PaletteComponent;
    }());
    if (false) {
        /**
         * Palette initialization function. Returns a go.Palette.
         * Do not initialize model data in this function.
         * @type {?}
         */
        PaletteComponent.prototype.initPalette;
        /** @type {?} */
        PaletteComponent.prototype.nodeDataArray;
        /** @type {?} */
        PaletteComponent.prototype.linkDataArray;
        /** @type {?} */
        PaletteComponent.prototype.modelData;
        /** @type {?} */
        PaletteComponent.prototype.divClassName;
        /** @type {?} */
        PaletteComponent.prototype.modelChangedListener;
        /** @type {?} */
        PaletteComponent.prototype.modelChange;
        /** @type {?} */
        PaletteComponent.prototype.paletteDiv;
        /** @type {?} */
        PaletteComponent.prototype.palette;
        /** @type {?} */
        PaletteComponent.prototype._ndaDiffer;
        /** @type {?} */
        PaletteComponent.prototype._ldaDiffer;
        /**
         * @type {?}
         * @private
         */
        PaletteComponent.prototype._mdDiffer;
        /**
         * @type {?}
         * @private
         */
        PaletteComponent.prototype._differs;
        /**
         * @type {?}
         * @private
         */
        PaletteComponent.prototype._kvdiffers;
        /** @type {?} */
        PaletteComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/overview.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OverviewComponent = /** @class */ (function () {
        function OverviewComponent(zone) {
            this.zone = zone;
            // The Diagram to observe with the Overview
            this.observedDiagram = null;
            // The Overview itself
            this.overview = null;
        }
        /**
         * Initialize the overview
         */
        /**
         * Initialize the overview
         * @return {?}
         */
        OverviewComponent.prototype.ngAfterViewInit = /**
         * Initialize the overview
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.overviewDiv)
                return;
            if (this.initOverview) {
                this.overview = this.initOverview();
            }
            else {
                this.overview = new gojs.Overview();
                this.overview.contentAlignment = gojs.Spot.Center;
            }
            // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
            // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
            // If some state-altering behavior must happen on a mousemove event inside the overview,
            // you will have to using zone.run() to make sure that event triggers angular change detection
            this.overview.addEventListener = (/**
             * @param {?} DOMElement
             * @param {?} name
             * @param {?} listener
             * @param {?} capture
             * @return {?}
             */
            function (DOMElement, name, listener, capture) {
                /** @type {?} */
                var superAddEventListener = gojs.Diagram.prototype.addEventListener;
                if (name === 'mousemove') {
                    _this.zone.runOutsideAngular((/**
                     * @return {?}
                     */
                    function () { return superAddEventListener.call(_this, DOMElement, name, listener, capture); }));
                }
                else {
                    _this.zone.run((/**
                     * @return {?}
                     */
                    function () {
                        superAddEventListener.call(_this, DOMElement, name, listener, capture);
                    }));
                }
            });
            this.overview.div = this.overviewDiv.nativeElement;
        };
        /**
         * Only update when the observed diagram changes
         * @param changes
         */
        /**
         * Only update when the observed diagram changes
         * @param {?} changes
         * @return {?}
         */
        OverviewComponent.prototype.ngOnChanges = /**
         * Only update when the observed diagram changes
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (!this.overview)
                return;
            if (changes && changes.observedDiagram && changes.observedDiagram.currentValue !== changes.observedDiagram.previousValue) {
                this.overview.observed = changes.observedDiagram.currentValue;
            }
        };
        OverviewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'gojs-overview',
                        template: '<div #ngOverview [className]=divClassName></div>'
                    }] }
        ];
        /** @nocollapse */
        OverviewComponent.ctorParameters = function () { return [
            { type: core.NgZone }
        ]; };
        OverviewComponent.propDecorators = {
            initOverview: [{ type: core.Input }],
            divClassName: [{ type: core.Input }],
            observedDiagram: [{ type: core.Input }],
            overviewDiv: [{ type: core.ViewChild, args: ['ngOverview', { static: true },] }]
        };
        return OverviewComponent;
    }());
    if (false) {
        /** @type {?} */
        OverviewComponent.prototype.initOverview;
        /** @type {?} */
        OverviewComponent.prototype.divClassName;
        /** @type {?} */
        OverviewComponent.prototype.observedDiagram;
        /** @type {?} */
        OverviewComponent.prototype.overviewDiv;
        /** @type {?} */
        OverviewComponent.prototype.overview;
        /** @type {?} */
        OverviewComponent.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/gojs-angular.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var GojsAngularModule = /** @class */ (function () {
        function GojsAngularModule() {
        }
        GojsAngularModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            DiagramComponent,
                            OverviewComponent,
                            PaletteComponent
                        ],
                        imports: [],
                        exports: [
                            DiagramComponent,
                            OverviewComponent,
                            PaletteComponent
                        ]
                    },] }
        ];
        return GojsAngularModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/data-sync.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DataSyncService = /** @class */ (function () {
        function DataSyncService() {
        }
        /**
         * Sync a node data array with a set of changes
         * @param changes The set of changes to the GoJS model
         * @param nodeData The node data array to merge these changes with
         * @returns A node data array, merged with the changes
         */
        /**
         * Sync a node data array with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} nodeData The node data array to merge these changes with
         * @return {?} A node data array, merged with the changes
         */
        DataSyncService.syncNodeData = /**
         * Sync a node data array with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} nodeData The node data array to merge these changes with
         * @return {?} A node data array, merged with the changes
         */
        function (changes, nodeData) {
            if (!changes)
                return nodeData;
            if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys)
                return nodeData;
            // maintain a map of modified nodes for fast lookup during insertion
            /** @type {?} */
            var modifiedNodesMap = new gojs.Map();
            // account for modified node data
            if (changes.modifiedNodeData) {
                changes.modifiedNodeData.forEach((/**
                 * @param {?} nd
                 * @return {?}
                 */
                function (nd) {
                    modifiedNodesMap.set(nd.key, nd);
                    /** @type {?} */
                    var key = nd.key;
                    for (var i = 0; i < nodeData.length; i++) {
                        /** @type {?} */
                        var ndEntry = nodeData[i];
                        if (ndEntry.key === key) {
                            nodeData[i] = nd;
                        }
                    }
                }));
            }
            // account for inserted node data
            if (changes.insertedNodeKeys) {
                changes.insertedNodeKeys.forEach((/**
                 * @param {?} key
                 * @return {?}
                 */
                function (key) {
                    /** @type {?} */
                    var nd = modifiedNodesMap.get(key);
                    if (nd) {
                        nodeData.push(nd);
                    }
                }));
            }
            // account for removed node data
            if (changes.removedNodeKeys) {
                nodeData = nodeData.filter((/**
                 * @param {?} nd
                 * @return {?}
                 */
                function (nd) {
                    if (changes.removedNodeKeys.includes(nd.key)) {
                        return false;
                    }
                    return true;
                }));
            }
            return nodeData;
        };
        /**
         * Sync a link data array with a set of changes
         * @param changes The set of changes to the GoJS model
         * @param linkData The link data array to merge these changes with
         * @returns A link data array, merged with the changes
         */
        /**
         * Sync a link data array with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} linkData The link data array to merge these changes with
         * @return {?} A link data array, merged with the changes
         */
        DataSyncService.syncLinkData = /**
         * Sync a link data array with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} linkData The link data array to merge these changes with
         * @return {?} A link data array, merged with the changes
         */
        function (changes, linkData) {
            if (!changes)
                return linkData;
            if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys)
                return linkData;
            // maintain a map of modified nodes for fast lookup during insertion
            /** @type {?} */
            var modifiedLinksMap = new gojs.Map();
            // account for modified link data
            if (changes.modifiedLinkData) {
                changes.modifiedLinkData.forEach((/**
                 * @param {?} ld
                 * @return {?}
                 */
                function (ld) {
                    modifiedLinksMap.set(ld.key, ld);
                    /** @type {?} */
                    var key = ld.key;
                    for (var i = 0; i < linkData.length; i++) {
                        /** @type {?} */
                        var ldEntry = linkData[i];
                        if (ldEntry.key === key) {
                            linkData[i] = ld;
                        }
                    }
                }));
            }
            // account for inserted link data
            if (changes.insertedLinkKeys) {
                changes.insertedLinkKeys.forEach((/**
                 * @param {?} key
                 * @return {?}
                 */
                function (key) {
                    /** @type {?} */
                    var nd = modifiedLinksMap.get(key);
                    if (nd) {
                        linkData.push(nd);
                    }
                }));
            }
            // account for removed link data
            if (changes.removedLinkKeys) {
                linkData = linkData.filter((/**
                 * @param {?} ld
                 * @return {?}
                 */
                function (ld) {
                    if (changes.removedLinkKeys.includes(ld.key)) {
                        return false;
                    }
                    return true;
                }));
            }
            return linkData;
        };
        /**
         * Sync modelData with a set of changes
         * @param changes The set of changes to the GoJS model
         * @param modelData The modelData to merge these changes with
         * @returns A modelData object, merged with the changes
         */
        /**
         * Sync modelData with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} modelData The modelData to merge these changes with
         * @return {?} A modelData object, merged with the changes
         */
        DataSyncService.syncModelData = /**
         * Sync modelData with a set of changes
         * @param {?} changes The set of changes to the GoJS model
         * @param {?} modelData The modelData to merge these changes with
         * @return {?} A modelData object, merged with the changes
         */
        function (changes, modelData) {
            if (!changes)
                return modelData;
            if (!changes.modelData)
                return modelData;
            if (changes.modelData) {
                return changes.modelData;
            }
        };
        DataSyncService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        DataSyncService.ctorParameters = function () { return []; };
        /** @nocollapse */ DataSyncService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function DataSyncService_Factory() { return new DataSyncService(); }, token: DataSyncService, providedIn: "root" });
        return DataSyncService;
    }());

    exports.DataSyncService = DataSyncService;
    exports.DiagramComponent = DiagramComponent;
    exports.GojsAngularModule = GojsAngularModule;
    exports.OverviewComponent = OverviewComponent;
    exports.PaletteComponent = PaletteComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=gojs-angular.umd.js.map
