/**
 * @fileoverview added by tsickle
 * Generated from: lib/diagram.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Input, IterableDiffers, KeyValueDiffers, NgZone, Output, ViewChild } from '@angular/core';
import * as go from 'gojs';
export class DiagramComponent {
    /**
     * @param {?} _differs
     * @param {?} _kvdiffers
     * @param {?} zone
     */
    constructor(_differs, _kvdiffers, zone) {
        this._differs = _differs;
        this._kvdiffers = _kvdiffers;
        this.zone = zone;
        // Link data for diagram
        this.linkDataArray = null; // optional
        // optional
        // Model data for diagram
        this.modelData = null; // optional
        // model changed listener function for diagram
        this.modelChangedListener = null;
        // event emitter -- fires when diagram model changes. Capture this emitted event in parent component
        this.modelChange = new EventEmitter();
        this.diagram = null;
        // differs used to check if there have been changed to the array @Inputs
        // without them, changes to the input arrays won't register in ngOnChanges,
        // since the array reference itself may be the same
        this._ndaDiffer = this._differs.find([]).create(null);
        this._ldaDiffer = this._differs.find([]).create(null);
        // also watch if model data changes; this differ must be initialized in ngOnInit
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // initialize the differ that listens for changes to modelData object
        if (this.modelData) {
            this._mdDiffer = this._kvdiffers.find(this.modelData).create();
        }
    } // end ngOnInit
    // end ngOnInit
    /**
     * Initializes diagram / model after view init
     * @return {?}
     */
    ngAfterViewInit() {
        this.diagram = this.initDiagram();
        // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
        // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
        // If some state-altering behavior must happen on a mousemove event inside the diagram,
        // you will have to using zone.run() to make sure that event triggers angular change detection
        this.diagram.addEventListener = (/**
         * @param {?} DOMElement
         * @param {?} name
         * @param {?} listener
         * @param {?} capture
         * @return {?}
         */
        (DOMElement, name, listener, capture) => {
            /** @type {?} */
            const superAddEventListener = go.Diagram.prototype.addEventListener;
            if (name === 'mousemove') {
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => superAddEventListener.call(this, DOMElement, name, listener, capture)));
            }
            else {
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    superAddEventListener.call(this, DOMElement, name, listener, capture);
                }));
            }
        });
        // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
        // using the overridden addEventListener function above
        /** @type {?} */
        const divRef = this.diagramDiv.nativeElement;
        if (divRef === null)
            return;
        this.diagram.div = divRef;
        // initialize the Diagram's model
        this.diagram.delayInitialization((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const model = this.diagram.model;
            model.commit((/**
             * @param {?} m
             * @return {?}
             */
            (m) => {
                m.mergeNodeDataArray(m.cloneDeep(this.nodeDataArray));
                if (this.linkDataArray && m instanceof go.GraphLinksModel) {
                    m.mergeLinkDataArray(m.cloneDeep(this.linkDataArray));
                }
                if (this.modelData) {
                    m.assignAllDataProperties(m.modelData, this.modelData);
                }
            }), null);
        }));
        // initializer listener
        this.modelChangedListener = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e.isTransactionFinished) {
                // this must be done within a NgZone.run block, so changes are detected in the parent component
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const dataChanges = (/** @type {?} */ (e.model)).toIncrementalData(e);
                    this.modelChange.emit(dataChanges);
                }));
            }
        });
        this.diagram.addModelChangedListener(this.modelChangedListener);
    } // end ngAfterViewInit
    // end ngAfterViewInit
    /**
     * Always be checking if array Input data has changed (node and link data arrays)
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const nodeDataArrayChanges = this._ndaDiffer.diff(this.nodeDataArray);
        /** @type {?} */
        const linkDataArrayChanges = this._ldaDiffer.diff(this.linkDataArray);
        /** @type {?} */
        let modelDataChanges = null;
        if (this._mdDiffer) {
            modelDataChanges = this._mdDiffer.diff(this.modelData);
        }
        if (nodeDataArrayChanges || linkDataArrayChanges || modelDataChanges) {
            this.updateFromAppData();
        }
    } // end ngDoCheck
    // end ngDoCheck
    /**
     * Some input property has changed (or its contents changed) in parent component.
     * Update diagram data accordingly
     * @return {?}
     */
    updateFromAppData() {
        if (!this.diagram)
            return;
        /** @type {?} */
        const model = this.diagram.model;
        // don't need model change listener while performing known data updates
        if (this.modelChangedListener !== null)
            model.removeChangedListener(this.modelChangedListener);
        model.startTransaction('update data');
        model.mergeNodeDataArray(model.cloneDeep(this.nodeDataArray));
        if (this.linkDataArray && model instanceof go.GraphLinksModel) {
            model.mergeLinkDataArray(model.cloneDeep(this.linkDataArray));
        }
        if (this.modelData) {
            model.assignAllDataProperties(model.modelData, this.modelData);
        }
        model.commitTransaction('update data');
        // reset the model change listener
        if (this.modelChangedListener !== null)
            model.addChangedListener(this.modelChangedListener);
    }
}
DiagramComponent.decorators = [
    { type: Component, args: [{
                selector: 'gojs-diagram',
                template: '<div #ngDiagram [className]=divClassName></div>'
            }] }
];
/** @nocollapse */
DiagramComponent.ctorParameters = () => [
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: NgZone }
];
DiagramComponent.propDecorators = {
    initDiagram: [{ type: Input }],
    nodeDataArray: [{ type: Input }],
    linkDataArray: [{ type: Input }],
    modelData: [{ type: Input }],
    divClassName: [{ type: Input }],
    modelChangedListener: [{ type: Input }],
    modelChange: [{ type: Output }],
    diagramDiv: [{ type: ViewChild, args: ['ngDiagram', { static: true },] }]
};
if (false) {
    /**
     * Diagram initialization function. Returns a go.Diagram.
     * Do not initialize model data in this function.
     * @type {?}
     */
    DiagramComponent.prototype.initDiagram;
    /** @type {?} */
    DiagramComponent.prototype.nodeDataArray;
    /** @type {?} */
    DiagramComponent.prototype.linkDataArray;
    /** @type {?} */
    DiagramComponent.prototype.modelData;
    /** @type {?} */
    DiagramComponent.prototype.divClassName;
    /** @type {?} */
    DiagramComponent.prototype.modelChangedListener;
    /** @type {?} */
    DiagramComponent.prototype.modelChange;
    /** @type {?} */
    DiagramComponent.prototype.diagramDiv;
    /** @type {?} */
    DiagramComponent.prototype.diagram;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ndaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ldaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._mdDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._differs;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._kvdiffers;
    /** @type {?} */
    DiagramComponent.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhZ3JhbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9nb2pzLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlhZ3JhbS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBa0IsZUFBZSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3hKLE9BQU8sS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBTTNCLE1BQU0sT0FBTyxnQkFBZ0I7Ozs7OztJQW9DM0IsWUFBb0IsUUFBeUIsRUFBVSxVQUEyQixFQUFTLElBQVk7UUFBbkYsYUFBUSxHQUFSLFFBQVEsQ0FBaUI7UUFBVSxlQUFVLEdBQVYsVUFBVSxDQUFpQjtRQUFTLFNBQUksR0FBSixJQUFJLENBQVE7O1FBeEJ2RixrQkFBYSxHQUF5QixJQUFJLENBQUMsQ0FBQyxXQUFXOzs7UUFHdkQsY0FBUyxHQUFrQixJQUFJLENBQUMsQ0FBQyxXQUFXOztRQU01Qyx5QkFBb0IsR0FBd0MsSUFBSSxDQUFDOztRQUdoRSxnQkFBVyxHQUFxQyxJQUFJLFlBQVksRUFBc0IsQ0FBQztRQUdqRyxZQUFPLEdBQWUsSUFBSSxDQUFDO1FBVWhDLHdFQUF3RTtRQUN4RSwyRUFBMkU7UUFDM0UsbURBQW1EO1FBQ25ELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXRELGdGQUFnRjtJQUNsRixDQUFDOzs7O0lBRU0sUUFBUTtRQUNiLHFFQUFx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QUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1NBQy9EO1FBQ0QsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2xCLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUNoRTtRQUNELEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUV2QyxrQ0FBa0M7UUFDbEMsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEtBQUssSUFBSTtZQUFFLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUM5RixDQUFDOzs7WUFySkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxjQUFjO2dCQUN4QixRQUFRLEVBQUUsaURBQWlEO2FBQzVEOzs7O1lBTm9ELGVBQWU7WUFBa0IsZUFBZTtZQUFFLE1BQU07OzswQkFhMUcsS0FBSzs0QkFHTCxLQUFLOzRCQUdMLEtBQUs7d0JBR0wsS0FBSzsyQkFHTCxLQUFLO21DQUdMLEtBQUs7MEJBR0wsTUFBTTt5QkFFTixTQUFTLFNBQUMsV0FBVyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTs7Ozs7Ozs7SUFwQnhDLHVDQUE4Qzs7SUFHOUMseUNBQW9EOztJQUdwRCx5Q0FBMkQ7O0lBRzNELHFDQUFnRDs7SUFHaEQsd0NBQXFDOztJQUdyQyxnREFBaUY7O0lBR2pGLHVDQUF3Rzs7SUFFeEcsc0NBQXdFOztJQUN4RSxtQ0FBa0M7Ozs7O0lBR2xDLHNDQUF3Qjs7Ozs7SUFDeEIsc0NBQXdCOzs7OztJQUV4QixxQ0FBK0M7Ozs7O0lBR25DLG9DQUFpQzs7Ozs7SUFBRSxzQ0FBbUM7O0lBQUUsZ0NBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBJdGVyYWJsZURpZmZlcnMsIEtleVZhbHVlRGlmZmVyLCBLZXlWYWx1ZURpZmZlcnMsIE5nWm9uZSwgT3V0cHV0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0ICogYXMgZ28gZnJvbSAnZ29qcyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2dvanMtZGlhZ3JhbScsXHJcbiAgdGVtcGxhdGU6ICc8ZGl2ICNuZ0RpYWdyYW0gW2NsYXNzTmFtZV09ZGl2Q2xhc3NOYW1lPjwvZGl2PidcclxufSlcclxuZXhwb3J0IGNsYXNzIERpYWdyYW1Db21wb25lbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEaWFncmFtIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBSZXR1cm5zIGEgZ28uRGlhZ3JhbS5cclxuICAgKiBEbyBub3QgaW5pdGlhbGl6ZSBtb2RlbCBkYXRhIGluIHRoaXMgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgQElucHV0KCkgcHVibGljIGluaXREaWFncmFtOiAoKSA9PiBnby5EaWFncmFtO1xyXG5cclxuICAvLyBOb2RlIGRhdGEgZm9yIGRpYWdyYW1cclxuICBASW5wdXQoKSBwdWJsaWMgbm9kZURhdGFBcnJheTogQXJyYXk8Z28uT2JqZWN0RGF0YT47XHJcblxyXG4gIC8vIExpbmsgZGF0YSBmb3IgZGlhZ3JhbVxyXG4gIEBJbnB1dCgpIHB1YmxpYyBsaW5rRGF0YUFycmF5OiBBcnJheTxnby5PYmplY3REYXRhPiA9IG51bGw7IC8vIG9wdGlvbmFsXHJcblxyXG4gIC8vIE1vZGVsIGRhdGEgZm9yIGRpYWdyYW1cclxuICBASW5wdXQoKSBwdWJsaWMgbW9kZWxEYXRhOiBnby5PYmplY3REYXRhID0gbnVsbDsgLy8gb3B0aW9uYWxcclxuXHJcbiAgLy8gRGlhZ3JhbSBkaXYgY2xhc3MgbmFtZS4gVXNlIHRoaXMgbmFtZSB0byBzdHlsZSB5b3VyIGRpYWdyYW0gaW4gQ1NTXHJcbiAgQElucHV0KCkgcHVibGljIGRpdkNsYXNzTmFtZTogc3RyaW5nO1xyXG5cclxuICAvLyBtb2RlbCBjaGFuZ2VkIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciBkaWFncmFtXHJcbiAgQElucHV0KCkgcHVibGljIG1vZGVsQ2hhbmdlZExpc3RlbmVyOiAoZTogZ28uQ2hhbmdlZEV2ZW50KSA9PiB2b2lkIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIC8vIGV2ZW50IGVtaXR0ZXIgLS0gZmlyZXMgd2hlbiBkaWFncmFtIG1vZGVsIGNoYW5nZXMuIENhcHR1cmUgdGhpcyBlbWl0dGVkIGV2ZW50IGluIHBhcmVudCBjb21wb25lbnRcclxuICBAT3V0cHV0KCkgcHVibGljIG1vZGVsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Z28uSW5jcmVtZW50YWxEYXRhPiA9IG5ldyBFdmVudEVtaXR0ZXI8Z28uSW5jcmVtZW50YWxEYXRhPigpO1xyXG5cclxuICBAVmlld0NoaWxkKCduZ0RpYWdyYW0nLCB7IHN0YXRpYzogdHJ1ZSB9KSBwdWJsaWMgZGlhZ3JhbURpdjogRWxlbWVudFJlZjtcclxuICBwdWJsaWMgZGlhZ3JhbTogZ28uRGlhZ3JhbSA9IG51bGw7XHJcblxyXG4gIC8vIGRpZmZlcnMgZm9yIGFycmF5IGlucHV0cyAobm9kZSAvIGxpbmsgZGF0YSBhcnJheXMpXHJcbiAgcHJpdmF0ZSBfbmRhRGlmZmVyOiBhbnk7XHJcbiAgcHJpdmF0ZSBfbGRhRGlmZmVyOiBhbnk7XHJcbiAgLy8gZGlmZmVyIGZvciBtb2RlbERhdGEgb2JqZWN0XHJcbiAgcHJpdmF0ZSBfbWREaWZmZXI6IEtleVZhbHVlRGlmZmVyPHN0cmluZywgYW55PjtcclxuXHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywgcHJpdmF0ZSBfa3ZkaWZmZXJzOiBLZXlWYWx1ZURpZmZlcnMsIHB1YmxpYyB6b25lOiBOZ1pvbmUpIHtcclxuICAgIC8vIGRpZmZlcnMgdXNlZCB0byBjaGVjayBpZiB0aGVyZSBoYXZlIGJlZW4gY2hhbmdlZCB0byB0aGUgYXJyYXkgQElucHV0c1xyXG4gICAgLy8gd2l0aG91dCB0aGVtLCBjaGFuZ2VzIHRvIHRoZSBpbnB1dCBhcnJheXMgd29uJ3QgcmVnaXN0ZXIgaW4gbmdPbkNoYW5nZXMsXHJcbiAgICAvLyBzaW5jZSB0aGUgYXJyYXkgcmVmZXJlbmNlIGl0c2VsZiBtYXkgYmUgdGhlIHNhbWVcclxuICAgIHRoaXMuX25kYURpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZChbXSkuY3JlYXRlKG51bGwpO1xyXG4gICAgdGhpcy5fbGRhRGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKFtdKS5jcmVhdGUobnVsbCk7XHJcblxyXG4gICAgLy8gYWxzbyB3YXRjaCBpZiBtb2RlbCBkYXRhIGNoYW5nZXM7IHRoaXMgZGlmZmVyIG11c3QgYmUgaW5pdGlhbGl6ZWQgaW4gbmdPbkluaXRcclxuICB9XHJcblxyXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcclxuICAgIC8vIGluaXRpYWxpemUgdGhlIGRpZmZlciB0aGF0IGxpc3RlbnMgZm9yIGNoYW5nZXMgdG8gbW9kZWxEYXRhIG9iamVjdFxyXG4gICAgaWYgKHRoaXMubW9kZWxEYXRhKSB7XHJcbiAgICAgIHRoaXMuX21kRGlmZmVyID0gdGhpcy5fa3ZkaWZmZXJzLmZpbmQodGhpcy5tb2RlbERhdGEpLmNyZWF0ZSgpO1xyXG4gICAgfVxyXG4gIH0gLy8gZW5kIG5nT25Jbml0XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIGRpYWdyYW0gLyBtb2RlbCBhZnRlciB2aWV3IGluaXRcclxuICAgKi9cclxuICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCkge1xyXG4gICAgdGhpcy5kaWFncmFtID0gdGhpcy5pbml0RGlhZ3JhbSgpO1xyXG5cclxuICAgIC8vIFRoaXMgYml0IG9mIGNvZGUgbWFrZXMgc3VyZSB0aGUgbW91c2Vtb3ZlIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgY2FudmFzIGFyZSBydW4gb3V0c2lkZSBOZ1pvbmVcclxuICAgIC8vIFRoaXMgbWFrZXMgaXQgc28gY2hhbmdlIGRldGVjdGlvbiBpc24ndCB0cmlnZ2VyZWQgZXZlcnkgdGltZSB0aGUgbW91c2UgaXMgbW92ZWQgaW5zaWRlIHRoZSBjYW52YXMsIGdyZWF0bHkgaW1wcm92aW5nIHBlcmZvcm1hbmNlXHJcbiAgICAvLyBJZiBzb21lIHN0YXRlLWFsdGVyaW5nIGJlaGF2aW9yIG11c3QgaGFwcGVuIG9uIGEgbW91c2Vtb3ZlIGV2ZW50IGluc2lkZSB0aGUgZGlhZ3JhbSxcclxuICAgIC8vIHlvdSB3aWxsIGhhdmUgdG8gdXNpbmcgem9uZS5ydW4oKSB0byBtYWtlIHN1cmUgdGhhdCBldmVudCB0cmlnZ2VycyBhbmd1bGFyIGNoYW5nZSBkZXRlY3Rpb25cclxuICAgIHRoaXMuZGlhZ3JhbS5hZGRFdmVudExpc3RlbmVyID0gKERPTUVsZW1lbnQ6IEVsZW1lbnQgfCBXaW5kb3cgfCBEb2N1bWVudCwgbmFtZTogc3RyaW5nLCBsaXN0ZW5lcjogYW55LCBjYXB0dXJlOiBib29sZWFuKSA9PiB7XHJcbiAgICAgIGNvbnN0IHN1cGVyQWRkRXZlbnRMaXN0ZW5lciA9IGdvLkRpYWdyYW0ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XHJcbiAgICAgIGlmIChuYW1lID09PSAnbW91c2Vtb3ZlJykge1xyXG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBzdXBlckFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBET01FbGVtZW50LCBuYW1lLCBsaXN0ZW5lciwgY2FwdHVyZSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgc3VwZXJBZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgRE9NRWxlbWVudCwgbmFtZSwgbGlzdGVuZXIsIGNhcHR1cmUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGFzc2lnbiB0aGUgRGlhZ3JhbSdzIGRpdiwgd2hpY2ggKGFtb25nIG1hbnkgb3RoZXIgdGhpbmdzKSB3aWxsIGF0dGFjaCBhIGJ1bmNoIG9mIGxpc3RlbmVycyB0byB0aGUgY2FudmFzLFxyXG4gICAgLy8gdXNpbmcgdGhlIG92ZXJyaWRkZW4gYWRkRXZlbnRMaXN0ZW5lciBmdW5jdGlvbiBhYm92ZVxyXG4gICAgY29uc3QgZGl2UmVmID0gdGhpcy5kaWFncmFtRGl2Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICBpZiAoZGl2UmVmID09PSBudWxsKSByZXR1cm47XHJcbiAgICB0aGlzLmRpYWdyYW0uZGl2ID0gZGl2UmVmO1xyXG5cclxuICAgIC8vIGluaXRpYWxpemUgdGhlIERpYWdyYW0ncyBtb2RlbFxyXG4gICAgdGhpcy5kaWFncmFtLmRlbGF5SW5pdGlhbGl6YXRpb24oKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb2RlbCA9IHRoaXMuZGlhZ3JhbS5tb2RlbDtcclxuICAgICAgbW9kZWwuY29tbWl0KChtOiBnby5Nb2RlbCkgPT4ge1xyXG4gICAgICAgIG0ubWVyZ2VOb2RlRGF0YUFycmF5KG0uY2xvbmVEZWVwKHRoaXMubm9kZURhdGFBcnJheSkpO1xyXG4gICAgICAgIGlmICh0aGlzLmxpbmtEYXRhQXJyYXkgJiYgbSBpbnN0YW5jZW9mIGdvLkdyYXBoTGlua3NNb2RlbCkge1xyXG4gICAgICAgICAgbS5tZXJnZUxpbmtEYXRhQXJyYXkobS5jbG9uZURlZXAodGhpcy5saW5rRGF0YUFycmF5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1vZGVsRGF0YSkge1xyXG4gICAgICAgICAgbS5hc3NpZ25BbGxEYXRhUHJvcGVydGllcyhtLm1vZGVsRGF0YSwgdGhpcy5tb2RlbERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgbnVsbCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBpbml0aWFsaXplciBsaXN0ZW5lclxyXG4gICAgdGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lciA9IChlOiBnby5DaGFuZ2VkRXZlbnQpID0+IHtcclxuICAgICAgaWYgKGUuaXNUcmFuc2FjdGlvbkZpbmlzaGVkKSB7XHJcbiAgICAgICAgLy8gdGhpcyBtdXN0IGJlIGRvbmUgd2l0aGluIGEgTmdab25lLnJ1biBibG9jaywgc28gY2hhbmdlcyBhcmUgZGV0ZWN0ZWQgaW4gdGhlIHBhcmVudCBjb21wb25lbnRcclxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGRhdGFDaGFuZ2VzID0gZS5tb2RlbCEudG9JbmNyZW1lbnRhbERhdGEoZSk7XHJcbiAgICAgICAgICB0aGlzLm1vZGVsQ2hhbmdlLmVtaXQoZGF0YUNoYW5nZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5kaWFncmFtLmFkZE1vZGVsQ2hhbmdlZExpc3RlbmVyKHRoaXMubW9kZWxDaGFuZ2VkTGlzdGVuZXIpO1xyXG5cclxuICB9IC8vIGVuZCBuZ0FmdGVyVmlld0luaXRcclxuXHJcbiAgLyoqXHJcbiAgICogQWx3YXlzIGJlIGNoZWNraW5nIGlmIGFycmF5IElucHV0IGRhdGEgaGFzIGNoYW5nZWQgKG5vZGUgYW5kIGxpbmsgZGF0YSBhcnJheXMpXHJcbiAgICovXHJcbiAgcHVibGljIG5nRG9DaGVjaygpIHtcclxuICAgIGNvbnN0IG5vZGVEYXRhQXJyYXlDaGFuZ2VzID0gdGhpcy5fbmRhRGlmZmVyLmRpZmYodGhpcy5ub2RlRGF0YUFycmF5KTtcclxuICAgIGNvbnN0IGxpbmtEYXRhQXJyYXlDaGFuZ2VzID0gdGhpcy5fbGRhRGlmZmVyLmRpZmYodGhpcy5saW5rRGF0YUFycmF5KTtcclxuICAgIGxldCBtb2RlbERhdGFDaGFuZ2VzID0gbnVsbDtcclxuICAgIGlmICh0aGlzLl9tZERpZmZlcikge1xyXG4gICAgICBtb2RlbERhdGFDaGFuZ2VzID0gdGhpcy5fbWREaWZmZXIuZGlmZih0aGlzLm1vZGVsRGF0YSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZURhdGFBcnJheUNoYW5nZXMgfHwgbGlua0RhdGFBcnJheUNoYW5nZXMgfHwgbW9kZWxEYXRhQ2hhbmdlcykge1xyXG4gICAgICB0aGlzLnVwZGF0ZUZyb21BcHBEYXRhKCk7XHJcbiAgICB9XHJcbiAgfSAvLyBlbmQgbmdEb0NoZWNrXHJcblxyXG4gIC8qKlxyXG4gICAqIFNvbWUgaW5wdXQgcHJvcGVydHkgaGFzIGNoYW5nZWQgKG9yIGl0cyBjb250ZW50cyBjaGFuZ2VkKSBpbiBwYXJlbnQgY29tcG9uZW50LlxyXG4gICAqIFVwZGF0ZSBkaWFncmFtIGRhdGEgYWNjb3JkaW5nbHlcclxuICAgKi9cclxuICBwdWJsaWMgdXBkYXRlRnJvbUFwcERhdGEoKSB7XHJcbiAgICBpZiAoIXRoaXMuZGlhZ3JhbSkgcmV0dXJuO1xyXG4gICAgY29uc3QgbW9kZWwgPSB0aGlzLmRpYWdyYW0ubW9kZWw7XHJcbiAgICAvLyBkb24ndCBuZWVkIG1vZGVsIGNoYW5nZSBsaXN0ZW5lciB3aGlsZSBwZXJmb3JtaW5nIGtub3duIGRhdGEgdXBkYXRlc1xyXG4gICAgaWYgKHRoaXMubW9kZWxDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIG1vZGVsLnJlbW92ZUNoYW5nZWRMaXN0ZW5lcih0aGlzLm1vZGVsQ2hhbmdlZExpc3RlbmVyKTtcclxuXHJcbiAgICBtb2RlbC5zdGFydFRyYW5zYWN0aW9uKCd1cGRhdGUgZGF0YScpO1xyXG4gICAgbW9kZWwubWVyZ2VOb2RlRGF0YUFycmF5KG1vZGVsLmNsb25lRGVlcCh0aGlzLm5vZGVEYXRhQXJyYXkpKTtcclxuICAgIGlmICh0aGlzLmxpbmtEYXRhQXJyYXkgJiYgbW9kZWwgaW5zdGFuY2VvZiBnby5HcmFwaExpbmtzTW9kZWwpIHtcclxuICAgICAgbW9kZWwubWVyZ2VMaW5rRGF0YUFycmF5KG1vZGVsLmNsb25lRGVlcCh0aGlzLmxpbmtEYXRhQXJyYXkpKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1vZGVsRGF0YSkge1xyXG4gICAgICBtb2RlbC5hc3NpZ25BbGxEYXRhUHJvcGVydGllcyhtb2RlbC5tb2RlbERhdGEsIHRoaXMubW9kZWxEYXRhKTtcclxuICAgIH1cclxuICAgIG1vZGVsLmNvbW1pdFRyYW5zYWN0aW9uKCd1cGRhdGUgZGF0YScpO1xyXG5cclxuICAgIC8vIHJlc2V0IHRoZSBtb2RlbCBjaGFuZ2UgbGlzdGVuZXJcclxuICAgIGlmICh0aGlzLm1vZGVsQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSBtb2RlbC5hZGRDaGFuZ2VkTGlzdGVuZXIodGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lcik7XHJcbiAgfVxyXG5cclxufVxyXG4iXX0=