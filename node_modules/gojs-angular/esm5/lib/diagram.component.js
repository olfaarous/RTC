/**
 * @fileoverview added by tsickle
 * Generated from: lib/diagram.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Input, IterableDiffers, KeyValueDiffers, NgZone, Output, ViewChild } from '@angular/core';
import * as go from 'gojs';
var DiagramComponent = /** @class */ (function () {
    function DiagramComponent(_differs, _kvdiffers, zone) {
        this._differs = _differs;
        this._kvdiffers = _kvdiffers;
        this.zone = zone;
        // Link data for diagram
        this.linkDataArray = null; // optional
        // optional
        // Model data for diagram
        this.modelData = null; // optional
        // model changed listener function for diagram
        this.modelChangedListener = null;
        // event emitter -- fires when diagram model changes. Capture this emitted event in parent component
        this.modelChange = new EventEmitter();
        this.diagram = null;
        // differs used to check if there have been changed to the array @Inputs
        // without them, changes to the input arrays won't register in ngOnChanges,
        // since the array reference itself may be the same
        this._ndaDiffer = this._differs.find([]).create(null);
        this._ldaDiffer = this._differs.find([]).create(null);
        // also watch if model data changes; this differ must be initialized in ngOnInit
    }
    /**
     * @return {?}
     */
    DiagramComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // initialize the differ that listens for changes to modelData object
        if (this.modelData) {
            this._mdDiffer = this._kvdiffers.find(this.modelData).create();
        }
    }; // end ngOnInit
    /**
     * Initializes diagram / model after view init
     */
    // end ngOnInit
    /**
     * Initializes diagram / model after view init
     * @return {?}
     */
    DiagramComponent.prototype.ngAfterViewInit = 
    // end ngOnInit
    /**
     * Initializes diagram / model after view init
     * @return {?}
     */
    function () {
        var _this = this;
        this.diagram = this.initDiagram();
        // This bit of code makes sure the mousemove event listeners on the canvas are run outside NgZone
        // This makes it so change detection isn't triggered every time the mouse is moved inside the canvas, greatly improving performance
        // If some state-altering behavior must happen on a mousemove event inside the diagram,
        // you will have to using zone.run() to make sure that event triggers angular change detection
        this.diagram.addEventListener = (/**
         * @param {?} DOMElement
         * @param {?} name
         * @param {?} listener
         * @param {?} capture
         * @return {?}
         */
        function (DOMElement, name, listener, capture) {
            /** @type {?} */
            var superAddEventListener = go.Diagram.prototype.addEventListener;
            if (name === 'mousemove') {
                _this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () { return superAddEventListener.call(_this, DOMElement, name, listener, capture); }));
            }
            else {
                _this.zone.run((/**
                 * @return {?}
                 */
                function () {
                    superAddEventListener.call(_this, DOMElement, name, listener, capture);
                }));
            }
        });
        // assign the Diagram's div, which (among many other things) will attach a bunch of listeners to the canvas,
        // using the overridden addEventListener function above
        /** @type {?} */
        var divRef = this.diagramDiv.nativeElement;
        if (divRef === null)
            return;
        this.diagram.div = divRef;
        // initialize the Diagram's model
        this.diagram.delayInitialization((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var model = _this.diagram.model;
            model.commit((/**
             * @param {?} m
             * @return {?}
             */
            function (m) {
                m.mergeNodeDataArray(m.cloneDeep(_this.nodeDataArray));
                if (_this.linkDataArray && m instanceof go.GraphLinksModel) {
                    m.mergeLinkDataArray(m.cloneDeep(_this.linkDataArray));
                }
                if (_this.modelData) {
                    m.assignAllDataProperties(m.modelData, _this.modelData);
                }
            }), null);
        }));
        // initializer listener
        this.modelChangedListener = (/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            if (e.isTransactionFinished) {
                // this must be done within a NgZone.run block, so changes are detected in the parent component
                _this.zone.run((/**
                 * @return {?}
                 */
                function () {
                    /** @type {?} */
                    var dataChanges = (/** @type {?} */ (e.model)).toIncrementalData(e);
                    _this.modelChange.emit(dataChanges);
                }));
            }
        });
        this.diagram.addModelChangedListener(this.modelChangedListener);
    }; // end ngAfterViewInit
    /**
     * Always be checking if array Input data has changed (node and link data arrays)
     */
    // end ngAfterViewInit
    /**
     * Always be checking if array Input data has changed (node and link data arrays)
     * @return {?}
     */
    DiagramComponent.prototype.ngDoCheck = 
    // end ngAfterViewInit
    /**
     * Always be checking if array Input data has changed (node and link data arrays)
     * @return {?}
     */
    function () {
        /** @type {?} */
        var nodeDataArrayChanges = this._ndaDiffer.diff(this.nodeDataArray);
        /** @type {?} */
        var linkDataArrayChanges = this._ldaDiffer.diff(this.linkDataArray);
        /** @type {?} */
        var modelDataChanges = null;
        if (this._mdDiffer) {
            modelDataChanges = this._mdDiffer.diff(this.modelData);
        }
        if (nodeDataArrayChanges || linkDataArrayChanges || modelDataChanges) {
            this.updateFromAppData();
        }
    }; // end ngDoCheck
    /**
     * Some input property has changed (or its contents changed) in parent component.
     * Update diagram data accordingly
     */
    // end ngDoCheck
    /**
     * Some input property has changed (or its contents changed) in parent component.
     * Update diagram data accordingly
     * @return {?}
     */
    DiagramComponent.prototype.updateFromAppData = 
    // end ngDoCheck
    /**
     * Some input property has changed (or its contents changed) in parent component.
     * Update diagram data accordingly
     * @return {?}
     */
    function () {
        if (!this.diagram)
            return;
        /** @type {?} */
        var model = this.diagram.model;
        // don't need model change listener while performing known data updates
        if (this.modelChangedListener !== null)
            model.removeChangedListener(this.modelChangedListener);
        model.startTransaction('update data');
        model.mergeNodeDataArray(model.cloneDeep(this.nodeDataArray));
        if (this.linkDataArray && model instanceof go.GraphLinksModel) {
            model.mergeLinkDataArray(model.cloneDeep(this.linkDataArray));
        }
        if (this.modelData) {
            model.assignAllDataProperties(model.modelData, this.modelData);
        }
        model.commitTransaction('update data');
        // reset the model change listener
        if (this.modelChangedListener !== null)
            model.addChangedListener(this.modelChangedListener);
    };
    DiagramComponent.decorators = [
        { type: Component, args: [{
                    selector: 'gojs-diagram',
                    template: '<div #ngDiagram [className]=divClassName></div>'
                }] }
    ];
    /** @nocollapse */
    DiagramComponent.ctorParameters = function () { return [
        { type: IterableDiffers },
        { type: KeyValueDiffers },
        { type: NgZone }
    ]; };
    DiagramComponent.propDecorators = {
        initDiagram: [{ type: Input }],
        nodeDataArray: [{ type: Input }],
        linkDataArray: [{ type: Input }],
        modelData: [{ type: Input }],
        divClassName: [{ type: Input }],
        modelChangedListener: [{ type: Input }],
        modelChange: [{ type: Output }],
        diagramDiv: [{ type: ViewChild, args: ['ngDiagram', { static: true },] }]
    };
    return DiagramComponent;
}());
export { DiagramComponent };
if (false) {
    /**
     * Diagram initialization function. Returns a go.Diagram.
     * Do not initialize model data in this function.
     * @type {?}
     */
    DiagramComponent.prototype.initDiagram;
    /** @type {?} */
    DiagramComponent.prototype.nodeDataArray;
    /** @type {?} */
    DiagramComponent.prototype.linkDataArray;
    /** @type {?} */
    DiagramComponent.prototype.modelData;
    /** @type {?} */
    DiagramComponent.prototype.divClassName;
    /** @type {?} */
    DiagramComponent.prototype.modelChangedListener;
    /** @type {?} */
    DiagramComponent.prototype.modelChange;
    /** @type {?} */
    DiagramComponent.prototype.diagramDiv;
    /** @type {?} */
    DiagramComponent.prototype.diagram;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ndaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._ldaDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._mdDiffer;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._differs;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype._kvdiffers;
    /** @type {?} */
    DiagramComponent.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhZ3JhbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9nb2pzLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlhZ3JhbS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBa0IsZUFBZSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3hKLE9BQU8sS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRTNCO0lBd0NFLDBCQUFvQixRQUF5QixFQUFVLFVBQTJCLEVBQVMsSUFBWTtRQUFuRixhQUFRLEdBQVIsUUFBUSxDQUFpQjtRQUFVLGVBQVUsR0FBVixVQUFVLENBQWlCO1FBQVMsU0FBSSxHQUFKLElBQUksQ0FBUTs7UUF4QnZGLGtCQUFhLEdBQXlCLElBQUksQ0FBQyxDQUFDLFdBQVc7OztRQUd2RCxjQUFTLEdBQWtCLElBQUksQ0FBQyxDQUFDLFdBQVc7O1FBTTVDLHlCQUFvQixHQUF3QyxJQUFJLENBQUM7O1FBR2hFLGdCQUFXLEdBQXFDLElBQUksWUFBWSxFQUFzQixDQUFDO1FBR2pHLFlBQU8sR0FBZSxJQUFJLENBQUM7UUFVaEMsd0VBQXdFO1FBQ3hFLDJFQUEyRTtRQUMzRSxtREFBbUQ7UUFDbkQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdEQsZ0ZBQWdGO0lBQ2xGLENBQUM7Ozs7SUFFTSxtQ0FBUTs7O0lBQWY7UUFDRSxxRUFBcUU7UUFDckUsSUFBSSxJ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QUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1NBQy9EO1FBQ0QsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2xCLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUNoRTtRQUNELEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUV2QyxrQ0FBa0M7UUFDbEMsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEtBQUssSUFBSTtZQUFFLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUM5RixDQUFDOztnQkFySkYsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSxjQUFjO29CQUN4QixRQUFRLEVBQUUsaURBQWlEO2lCQUM1RDs7OztnQkFOb0QsZUFBZTtnQkFBa0IsZUFBZTtnQkFBRSxNQUFNOzs7OEJBYTFHLEtBQUs7Z0NBR0wsS0FBSztnQ0FHTCxLQUFLOzRCQUdMLEtBQUs7K0JBR0wsS0FBSzt1Q0FHTCxLQUFLOzhCQUdMLE1BQU07NkJBRU4sU0FBUyxTQUFDLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7O0lBeUgxQyx1QkFBQztDQUFBLEFBdkpELElBdUpDO1NBbkpZLGdCQUFnQjs7Ozs7OztJQU0zQix1Q0FBOEM7O0lBRzlDLHlDQUFvRDs7SUFHcEQseUNBQTJEOztJQUczRCxxQ0FBZ0Q7O0lBR2hELHdDQUFxQzs7SUFHckMsZ0RBQWlGOztJQUdqRix1Q0FBd0c7O0lBRXhHLHNDQUF3RTs7SUFDeEUsbUNBQWtDOzs7OztJQUdsQyxzQ0FBd0I7Ozs7O0lBQ3hCLHNDQUF3Qjs7Ozs7SUFFeEIscUNBQStDOzs7OztJQUduQyxvQ0FBaUM7Ozs7O0lBQUUsc0NBQW1DOztJQUFFLGdDQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgSXRlcmFibGVEaWZmZXJzLCBLZXlWYWx1ZURpZmZlciwgS2V5VmFsdWVEaWZmZXJzLCBOZ1pvbmUsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIGdvIGZyb20gJ2dvanMnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdnb2pzLWRpYWdyYW0nLFxyXG4gIHRlbXBsYXRlOiAnPGRpdiAjbmdEaWFncmFtIFtjbGFzc05hbWVdPWRpdkNsYXNzTmFtZT48L2Rpdj4nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBEaWFncmFtQ29tcG9uZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRGlhZ3JhbSBpbml0aWFsaXphdGlvbiBmdW5jdGlvbi4gUmV0dXJucyBhIGdvLkRpYWdyYW0uXHJcbiAgICogRG8gbm90IGluaXRpYWxpemUgbW9kZWwgZGF0YSBpbiB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpIHB1YmxpYyBpbml0RGlhZ3JhbTogKCkgPT4gZ28uRGlhZ3JhbTtcclxuXHJcbiAgLy8gTm9kZSBkYXRhIGZvciBkaWFncmFtXHJcbiAgQElucHV0KCkgcHVibGljIG5vZGVEYXRhQXJyYXk6IEFycmF5PGdvLk9iamVjdERhdGE+O1xyXG5cclxuICAvLyBMaW5rIGRhdGEgZm9yIGRpYWdyYW1cclxuICBASW5wdXQoKSBwdWJsaWMgbGlua0RhdGFBcnJheTogQXJyYXk8Z28uT2JqZWN0RGF0YT4gPSBudWxsOyAvLyBvcHRpb25hbFxyXG5cclxuICAvLyBNb2RlbCBkYXRhIGZvciBkaWFncmFtXHJcbiAgQElucHV0KCkgcHVibGljIG1vZGVsRGF0YTogZ28uT2JqZWN0RGF0YSA9IG51bGw7IC8vIG9wdGlvbmFsXHJcblxyXG4gIC8vIERpYWdyYW0gZGl2IGNsYXNzIG5hbWUuIFVzZSB0aGlzIG5hbWUgdG8gc3R5bGUgeW91ciBkaWFncmFtIGluIENTU1xyXG4gIEBJbnB1dCgpIHB1YmxpYyBkaXZDbGFzc05hbWU6IHN0cmluZztcclxuXHJcbiAgLy8gbW9kZWwgY2hhbmdlZCBsaXN0ZW5lciBmdW5jdGlvbiBmb3IgZGlhZ3JhbVxyXG4gIEBJbnB1dCgpIHB1YmxpYyBtb2RlbENoYW5nZWRMaXN0ZW5lcjogKGU6IGdvLkNoYW5nZWRFdmVudCkgPT4gdm9pZCB8IG51bGwgPSBudWxsO1xyXG5cclxuICAvLyBldmVudCBlbWl0dGVyIC0tIGZpcmVzIHdoZW4gZGlhZ3JhbSBtb2RlbCBjaGFuZ2VzLiBDYXB0dXJlIHRoaXMgZW1pdHRlZCBldmVudCBpbiBwYXJlbnQgY29tcG9uZW50XHJcbiAgQE91dHB1dCgpIHB1YmxpYyBtb2RlbENoYW5nZTogRXZlbnRFbWl0dGVyPGdvLkluY3JlbWVudGFsRGF0YT4gPSBuZXcgRXZlbnRFbWl0dGVyPGdvLkluY3JlbWVudGFsRGF0YT4oKTtcclxuXHJcbiAgQFZpZXdDaGlsZCgnbmdEaWFncmFtJywgeyBzdGF0aWM6IHRydWUgfSkgcHVibGljIGRpYWdyYW1EaXY6IEVsZW1lbnRSZWY7XHJcbiAgcHVibGljIGRpYWdyYW06IGdvLkRpYWdyYW0gPSBudWxsO1xyXG5cclxuICAvLyBkaWZmZXJzIGZvciBhcnJheSBpbnB1dHMgKG5vZGUgLyBsaW5rIGRhdGEgYXJyYXlzKVxyXG4gIHByaXZhdGUgX25kYURpZmZlcjogYW55O1xyXG4gIHByaXZhdGUgX2xkYURpZmZlcjogYW55O1xyXG4gIC8vIGRpZmZlciBmb3IgbW9kZWxEYXRhIG9iamVjdFxyXG4gIHByaXZhdGUgX21kRGlmZmVyOiBLZXlWYWx1ZURpZmZlcjxzdHJpbmcsIGFueT47XHJcblxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsIHByaXZhdGUgX2t2ZGlmZmVyczogS2V5VmFsdWVEaWZmZXJzLCBwdWJsaWMgem9uZTogTmdab25lKSB7XHJcbiAgICAvLyBkaWZmZXJzIHVzZWQgdG8gY2hlY2sgaWYgdGhlcmUgaGF2ZSBiZWVuIGNoYW5nZWQgdG8gdGhlIGFycmF5IEBJbnB1dHNcclxuICAgIC8vIHdpdGhvdXQgdGhlbSwgY2hhbmdlcyB0byB0aGUgaW5wdXQgYXJyYXlzIHdvbid0IHJlZ2lzdGVyIGluIG5nT25DaGFuZ2VzLFxyXG4gICAgLy8gc2luY2UgdGhlIGFycmF5IHJlZmVyZW5jZSBpdHNlbGYgbWF5IGJlIHRoZSBzYW1lXHJcbiAgICB0aGlzLl9uZGFEaWZmZXIgPSB0aGlzLl9kaWZmZXJzLmZpbmQoW10pLmNyZWF0ZShudWxsKTtcclxuICAgIHRoaXMuX2xkYURpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZChbXSkuY3JlYXRlKG51bGwpO1xyXG5cclxuICAgIC8vIGFsc28gd2F0Y2ggaWYgbW9kZWwgZGF0YSBjaGFuZ2VzOyB0aGlzIGRpZmZlciBtdXN0IGJlIGluaXRpYWxpemVkIGluIG5nT25Jbml0XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgbmdPbkluaXQoKSB7XHJcbiAgICAvLyBpbml0aWFsaXplIHRoZSBkaWZmZXIgdGhhdCBsaXN0ZW5zIGZvciBjaGFuZ2VzIHRvIG1vZGVsRGF0YSBvYmplY3RcclxuICAgIGlmICh0aGlzLm1vZGVsRGF0YSkge1xyXG4gICAgICB0aGlzLl9tZERpZmZlciA9IHRoaXMuX2t2ZGlmZmVycy5maW5kKHRoaXMubW9kZWxEYXRhKS5jcmVhdGUoKTtcclxuICAgIH1cclxuICB9IC8vIGVuZCBuZ09uSW5pdFxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplcyBkaWFncmFtIC8gbW9kZWwgYWZ0ZXIgdmlldyBpbml0XHJcbiAgICovXHJcbiAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcclxuICAgIHRoaXMuZGlhZ3JhbSA9IHRoaXMuaW5pdERpYWdyYW0oKTtcclxuXHJcbiAgICAvLyBUaGlzIGJpdCBvZiBjb2RlIG1ha2VzIHN1cmUgdGhlIG1vdXNlbW92ZSBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGNhbnZhcyBhcmUgcnVuIG91dHNpZGUgTmdab25lXHJcbiAgICAvLyBUaGlzIG1ha2VzIGl0IHNvIGNoYW5nZSBkZXRlY3Rpb24gaXNuJ3QgdHJpZ2dlcmVkIGV2ZXJ5IHRpbWUgdGhlIG1vdXNlIGlzIG1vdmVkIGluc2lkZSB0aGUgY2FudmFzLCBncmVhdGx5IGltcHJvdmluZyBwZXJmb3JtYW5jZVxyXG4gICAgLy8gSWYgc29tZSBzdGF0ZS1hbHRlcmluZyBiZWhhdmlvciBtdXN0IGhhcHBlbiBvbiBhIG1vdXNlbW92ZSBldmVudCBpbnNpZGUgdGhlIGRpYWdyYW0sXHJcbiAgICAvLyB5b3Ugd2lsbCBoYXZlIHRvIHVzaW5nIHpvbmUucnVuKCkgdG8gbWFrZSBzdXJlIHRoYXQgZXZlbnQgdHJpZ2dlcnMgYW5ndWxhciBjaGFuZ2UgZGV0ZWN0aW9uXHJcbiAgICB0aGlzLmRpYWdyYW0uYWRkRXZlbnRMaXN0ZW5lciA9IChET01FbGVtZW50OiBFbGVtZW50IHwgV2luZG93IHwgRG9jdW1lbnQsIG5hbWU6IHN0cmluZywgbGlzdGVuZXI6IGFueSwgY2FwdHVyZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICBjb25zdCBzdXBlckFkZEV2ZW50TGlzdGVuZXIgPSBnby5EaWFncmFtLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xyXG4gICAgICBpZiAobmFtZSA9PT0gJ21vdXNlbW92ZScpIHtcclxuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gc3VwZXJBZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgRE9NRWxlbWVudCwgbmFtZSwgbGlzdGVuZXIsIGNhcHR1cmUpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgICAgIHN1cGVyQWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIERPTUVsZW1lbnQsIG5hbWUsIGxpc3RlbmVyLCBjYXB0dXJlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBhc3NpZ24gdGhlIERpYWdyYW0ncyBkaXYsIHdoaWNoIChhbW9uZyBtYW55IG90aGVyIHRoaW5ncykgd2lsbCBhdHRhY2ggYSBidW5jaCBvZiBsaXN0ZW5lcnMgdG8gdGhlIGNhbnZhcyxcclxuICAgIC8vIHVzaW5nIHRoZSBvdmVycmlkZGVuIGFkZEV2ZW50TGlzdGVuZXIgZnVuY3Rpb24gYWJvdmVcclxuICAgIGNvbnN0IGRpdlJlZiA9IHRoaXMuZGlhZ3JhbURpdi5uYXRpdmVFbGVtZW50O1xyXG4gICAgaWYgKGRpdlJlZiA9PT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgdGhpcy5kaWFncmFtLmRpdiA9IGRpdlJlZjtcclxuXHJcbiAgICAvLyBpbml0aWFsaXplIHRoZSBEaWFncmFtJ3MgbW9kZWxcclxuICAgIHRoaXMuZGlhZ3JhbS5kZWxheUluaXRpYWxpemF0aW9uKCgpID0+IHtcclxuICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLmRpYWdyYW0ubW9kZWw7XHJcbiAgICAgIG1vZGVsLmNvbW1pdCgobTogZ28uTW9kZWwpID0+IHtcclxuICAgICAgICBtLm1lcmdlTm9kZURhdGFBcnJheShtLmNsb25lRGVlcCh0aGlzLm5vZGVEYXRhQXJyYXkpKTtcclxuICAgICAgICBpZiAodGhpcy5saW5rRGF0YUFycmF5ICYmIG0gaW5zdGFuY2VvZiBnby5HcmFwaExpbmtzTW9kZWwpIHtcclxuICAgICAgICAgIG0ubWVyZ2VMaW5rRGF0YUFycmF5KG0uY2xvbmVEZWVwKHRoaXMubGlua0RhdGFBcnJheSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tb2RlbERhdGEpIHtcclxuICAgICAgICAgIG0uYXNzaWduQWxsRGF0YVByb3BlcnRpZXMobS5tb2RlbERhdGEsIHRoaXMubW9kZWxEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIG51bGwpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaW5pdGlhbGl6ZXIgbGlzdGVuZXJcclxuICAgIHRoaXMubW9kZWxDaGFuZ2VkTGlzdGVuZXIgPSAoZTogZ28uQ2hhbmdlZEV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChlLmlzVHJhbnNhY3Rpb25GaW5pc2hlZCkge1xyXG4gICAgICAgIC8vIHRoaXMgbXVzdCBiZSBkb25lIHdpdGhpbiBhIE5nWm9uZS5ydW4gYmxvY2ssIHNvIGNoYW5nZXMgYXJlIGRldGVjdGVkIGluIHRoZSBwYXJlbnQgY29tcG9uZW50XHJcbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBkYXRhQ2hhbmdlcyA9IGUubW9kZWwhLnRvSW5jcmVtZW50YWxEYXRhKGUpO1xyXG4gICAgICAgICAgdGhpcy5tb2RlbENoYW5nZS5lbWl0KGRhdGFDaGFuZ2VzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuZGlhZ3JhbS5hZGRNb2RlbENoYW5nZWRMaXN0ZW5lcih0aGlzLm1vZGVsQ2hhbmdlZExpc3RlbmVyKTtcclxuXHJcbiAgfSAvLyBlbmQgbmdBZnRlclZpZXdJbml0XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsd2F5cyBiZSBjaGVja2luZyBpZiBhcnJheSBJbnB1dCBkYXRhIGhhcyBjaGFuZ2VkIChub2RlIGFuZCBsaW5rIGRhdGEgYXJyYXlzKVxyXG4gICAqL1xyXG4gIHB1YmxpYyBuZ0RvQ2hlY2soKSB7XHJcbiAgICBjb25zdCBub2RlRGF0YUFycmF5Q2hhbmdlcyA9IHRoaXMuX25kYURpZmZlci5kaWZmKHRoaXMubm9kZURhdGFBcnJheSk7XHJcbiAgICBjb25zdCBsaW5rRGF0YUFycmF5Q2hhbmdlcyA9IHRoaXMuX2xkYURpZmZlci5kaWZmKHRoaXMubGlua0RhdGFBcnJheSk7XHJcbiAgICBsZXQgbW9kZWxEYXRhQ2hhbmdlcyA9IG51bGw7XHJcbiAgICBpZiAodGhpcy5fbWREaWZmZXIpIHtcclxuICAgICAgbW9kZWxEYXRhQ2hhbmdlcyA9IHRoaXMuX21kRGlmZmVyLmRpZmYodGhpcy5tb2RlbERhdGEpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGVEYXRhQXJyYXlDaGFuZ2VzIHx8IGxpbmtEYXRhQXJyYXlDaGFuZ2VzIHx8IG1vZGVsRGF0YUNoYW5nZXMpIHtcclxuICAgICAgdGhpcy51cGRhdGVGcm9tQXBwRGF0YSgpO1xyXG4gICAgfVxyXG4gIH0gLy8gZW5kIG5nRG9DaGVja1xyXG5cclxuICAvKipcclxuICAgKiBTb21lIGlucHV0IHByb3BlcnR5IGhhcyBjaGFuZ2VkIChvciBpdHMgY29udGVudHMgY2hhbmdlZCkgaW4gcGFyZW50IGNvbXBvbmVudC5cclxuICAgKiBVcGRhdGUgZGlhZ3JhbSBkYXRhIGFjY29yZGluZ2x5XHJcbiAgICovXHJcbiAgcHVibGljIHVwZGF0ZUZyb21BcHBEYXRhKCkge1xyXG4gICAgaWYgKCF0aGlzLmRpYWdyYW0pIHJldHVybjtcclxuICAgIGNvbnN0IG1vZGVsID0gdGhpcy5kaWFncmFtLm1vZGVsO1xyXG4gICAgLy8gZG9uJ3QgbmVlZCBtb2RlbCBjaGFuZ2UgbGlzdGVuZXIgd2hpbGUgcGVyZm9ybWluZyBrbm93biBkYXRhIHVwZGF0ZXNcclxuICAgIGlmICh0aGlzLm1vZGVsQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSBtb2RlbC5yZW1vdmVDaGFuZ2VkTGlzdGVuZXIodGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lcik7XHJcblxyXG4gICAgbW9kZWwuc3RhcnRUcmFuc2FjdGlvbigndXBkYXRlIGRhdGEnKTtcclxuICAgIG1vZGVsLm1lcmdlTm9kZURhdGFBcnJheShtb2RlbC5jbG9uZURlZXAodGhpcy5ub2RlRGF0YUFycmF5KSk7XHJcbiAgICBpZiAodGhpcy5saW5rRGF0YUFycmF5ICYmIG1vZGVsIGluc3RhbmNlb2YgZ28uR3JhcGhMaW5rc01vZGVsKSB7XHJcbiAgICAgIG1vZGVsLm1lcmdlTGlua0RhdGFBcnJheShtb2RlbC5jbG9uZURlZXAodGhpcy5saW5rRGF0YUFycmF5KSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tb2RlbERhdGEpIHtcclxuICAgICAgbW9kZWwuYXNzaWduQWxsRGF0YVByb3BlcnRpZXMobW9kZWwubW9kZWxEYXRhLCB0aGlzLm1vZGVsRGF0YSk7XHJcbiAgICB9XHJcbiAgICBtb2RlbC5jb21taXRUcmFuc2FjdGlvbigndXBkYXRlIGRhdGEnKTtcclxuXHJcbiAgICAvLyByZXNldCB0aGUgbW9kZWwgY2hhbmdlIGxpc3RlbmVyXHJcbiAgICBpZiAodGhpcy5tb2RlbENoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkgbW9kZWwuYWRkQ2hhbmdlZExpc3RlbmVyKHRoaXMubW9kZWxDaGFuZ2VkTGlzdGVuZXIpO1xyXG4gIH1cclxuXHJcbn1cclxuIl19