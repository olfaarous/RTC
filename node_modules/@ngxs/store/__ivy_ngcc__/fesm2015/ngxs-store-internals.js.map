{"version":3,"sources":["/home/olfa/Desktop/Pixels/SB-Admin-BS4-Angular-8-master/node_modules/@ngxs/store/fesm2015/ngxs-store-internals.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6HC;;;gDAGC","file":"ngxs-store-internals.js","sourcesContent":["import { getPlatform, COMPILER_OPTIONS, Injectable, InjectionToken } from '@angular/core';\nimport { ReplaySubject } from 'rxjs';\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @param {?} a\r\n * @param {?} b\r\n * @return {?}\r\n */\r\nfunction defaultEqualityCheck(a, b) {\r\n    return a === b;\r\n}\r\n/**\r\n * @param {?} equalityCheck\r\n * @param {?} prev\r\n * @param {?} next\r\n * @return {?}\r\n */\r\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\r\n    if (prev === null || next === null || prev.length !== next.length) {\r\n        return false;\r\n    }\r\n    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\r\n    /** @type {?} */\r\n    const length = prev.length;\r\n    for (let i = 0; i < length; i++) {\r\n        if (!equalityCheck(prev[i], next[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Memoize a function on its last inputs only.\r\n * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\r\n *\r\n * @ignore\r\n * @template T\r\n * @param {?} func\r\n * @param {?=} equalityCheck\r\n * @return {?}\r\n */\r\nfunction memoize(func, equalityCheck = defaultEqualityCheck) {\r\n    /** @type {?} */\r\n    let lastArgs = null;\r\n    /** @type {?} */\r\n    let lastResult = null;\r\n    // we reference arguments instead of spreading them for performance reasons\r\n    /**\r\n     * @return {?}\r\n     */\r\n    function memoized() {\r\n        if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\r\n            // apply arguments instead of spreading for performance.\r\n            lastResult = ((/** @type {?} */ (func))).apply(null, arguments);\r\n        }\r\n        lastArgs = arguments;\r\n        return lastResult;\r\n    }\r\n    ((/** @type {?} */ (memoized))).reset = (/**\r\n     * @return {?}\r\n     */\r\n    function () {\r\n        // The hidden (for now) ability to reset the memoization\r\n        lastArgs = null;\r\n        lastResult = null;\r\n    });\r\n    return (/** @type {?} */ (memoized));\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @return {?}\r\n */\r\nfunction _isAngularInTestMode() {\r\n    /** @type {?} */\r\n    const platformRef = getPlatform();\r\n    if (!platformRef)\r\n        return false;\r\n    /** @type {?} */\r\n    const compilerOptions = platformRef.injector.get(COMPILER_OPTIONS, null);\r\n    if (!compilerOptions)\r\n        return false;\r\n    /** @type {?} */\r\n    const isInTestMode = compilerOptions.some((/**\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    (item) => {\r\n        /** @type {?} */\r\n        const providers = (item && item.providers) || [];\r\n        return providers.some((/**\r\n         * @param {?} provider\r\n         * @return {?}\r\n         */\r\n        (provider) => {\r\n            return ((provider && provider.provide && provider.provide.name === 'MockNgModuleResolver') ||\r\n                false);\r\n        }));\r\n    }));\r\n    return isInTestMode;\r\n}\r\n/** @type {?} */\r\nconst isAngularInTestMode = memoize(_isAngularInTestMode);\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass NgxsBootstrapper {\r\n    constructor() {\r\n        /**\r\n         * Use `ReplaySubject`, thus we can get cached value even if the stream is completed\r\n         */\r\n        this.bootstrap$ = new ReplaySubject(1);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get appBootstrapped$() {\r\n        return this.bootstrap$.asObservable();\r\n    }\r\n    /**\r\n     * This event will be emitted after attaching `ComponentRef` of the root component\r\n     * to the tree of views, that's a signal that application has been fully rendered\r\n     * @return {?}\r\n     */\r\n    bootstrap() {\r\n        this.bootstrap$.next(true);\r\n        this.bootstrap$.complete();\r\n    }\r\n}\r\nNgxsBootstrapper.decorators = [\r\n    { type: Injectable }\r\n];\r\nif (false) {\r\n    /**\r\n     * Use `ReplaySubject`, thus we can get cached value even if the stream is completed\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgxsBootstrapper.prototype.bootstrap$;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst INITIAL_STATE_TOKEN = new InjectionToken('INITIAL_STATE_TOKEN');\r\nclass InitialState {\r\n    /**\r\n     * @param {?} state\r\n     * @return {?}\r\n     */\r\n    static set(state) {\r\n        this.value = state;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    static pop() {\r\n        /** @type {?} */\r\n        const state = this.value;\r\n        this.value = {};\r\n        return state;\r\n    }\r\n}\r\nInitialState.value = {};\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    InitialState.value;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @see StateContextFactory as it's referenced by this token to be accessed by plugins internally\r\n * @type {?}\r\n */\r\nconst NGXS_STATE_CONTEXT_FACTORY = new InjectionToken('Internals.StateContextFactory');\r\n/**\r\n * @see StateFactory as it's referenced by this token to be accessed by plugins internally\r\n * @type {?}\r\n */\r\nconst NGXS_STATE_FACTORY = new InjectionToken('Internals.StateFactory');\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nexport { INITIAL_STATE_TOKEN, InitialState, NGXS_STATE_CONTEXT_FACTORY, NGXS_STATE_FACTORY, NgxsBootstrapper, isAngularInTestMode, memoize };\n"]}